{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cp2k-basis \u00a4 A library to parse CP2K basis sets and GTH pseudopotentials, which also comes with a webserver to find out and select a basis set and its matching pseudopotential for your CP2K calculations, similar to the basis set exchange . More info are provided there . Info Check out the live version, available at https://cp2k-basis.pierrebeaujean.net .","title":"Home"},{"location":"#cp2k-basis","text":"A library to parse CP2K basis sets and GTH pseudopotentials, which also comes with a webserver to find out and select a basis set and its matching pseudopotential for your CP2K calculations, similar to the basis set exchange . More info are provided there . Info Check out the live version, available at https://cp2k-basis.pierrebeaujean.net .","title":"cp2k-basis"},{"location":"about/","text":"About this project. \u00a4 TL;DR: This project, develloped by Pierre Beaujean , provides an easy way to select matching basis sets and GTH pseudopotentials for your CP2K calculation. For the rest, go to the basis set exchange \ud83d\ude03 What? \u00a4 Info If you are not familiar with the concept of basis set and pseudopotentials, check out this introduction . Why CP2K? \u00a4 CP2K is a quantum chemistry program that can perform atomistic simulations. It is especially known for mixing Gaussian and plane wave approaches, which are useful to perform ab initio molecular dynamics, among others . Why this if there is the basis set exchange? \u00a4 The basis set exchange (BSE), developed by MolSSI is a trustworthy provider of basis sets and effective core potentials (ECP) since a long time ago. It even provides an output for CP2K. In fact, this project has no intention of replacing the BSE, and users should happily continue to use it to fetch ECP and all-electron basis sets (don't forget to use the ALL potential if needed, thought). However, CP2K calculations can also use a pair of matching GTH potentials and corresponding basis sets . This is actually one of the first thing you learn when you try to use the CP2K program . They are not available in the BSE, so this is where this project is useful, by allowing the users to look through the library of available basis sets and pseudopotentials with a web interface similar to the BSE . Behind the scene, it also provides a library to read, write and store CP2K basis sets and potentials. Alternatives? \u00a4 The official cp2k-data repository , which might contain more up to date version of GTH potentials. This webpage , which provide an easy way to explore the previous repository. Other tools (related to input and output) are also listed in the CP2K documentation . How? \u00a4 For the moment, the basis sets and GTH pseudopotentials are taken from the /data directory of the CP2K repository . This project is developed using Python 3 , numpy and h5py (for the storage). The webserver is powered by flask . This documentation is built using mkdocs . If you are interested in that, maybe you want to help? If so, I'm happy to welcome your contributions ! Who? \u00a4 My name is Pierre Beaujean , and I'm a Ph.D. in quantum chemistry from the University of Namur (Belgium). I'm the main (and only) developer of this project, used in our lab. I use CP2K in the frame of my post-doctoral research, and I developed this project for all the reasons listed above.","title":"About"},{"location":"about/#about-this-project","text":"TL;DR: This project, develloped by Pierre Beaujean , provides an easy way to select matching basis sets and GTH pseudopotentials for your CP2K calculation. For the rest, go to the basis set exchange \ud83d\ude03","title":"About this project."},{"location":"about/#what","text":"Info If you are not familiar with the concept of basis set and pseudopotentials, check out this introduction .","title":"What?"},{"location":"about/#why-cp2k","text":"CP2K is a quantum chemistry program that can perform atomistic simulations. It is especially known for mixing Gaussian and plane wave approaches, which are useful to perform ab initio molecular dynamics, among others .","title":"Why CP2K?"},{"location":"about/#why-this-if-there-is-the-basis-set-exchange","text":"The basis set exchange (BSE), developed by MolSSI is a trustworthy provider of basis sets and effective core potentials (ECP) since a long time ago. It even provides an output for CP2K. In fact, this project has no intention of replacing the BSE, and users should happily continue to use it to fetch ECP and all-electron basis sets (don't forget to use the ALL potential if needed, thought). However, CP2K calculations can also use a pair of matching GTH potentials and corresponding basis sets . This is actually one of the first thing you learn when you try to use the CP2K program . They are not available in the BSE, so this is where this project is useful, by allowing the users to look through the library of available basis sets and pseudopotentials with a web interface similar to the BSE . Behind the scene, it also provides a library to read, write and store CP2K basis sets and potentials.","title":"Why this if there is the basis set exchange?"},{"location":"about/#alternatives","text":"The official cp2k-data repository , which might contain more up to date version of GTH potentials. This webpage , which provide an easy way to explore the previous repository. Other tools (related to input and output) are also listed in the CP2K documentation .","title":"Alternatives?"},{"location":"about/#how","text":"For the moment, the basis sets and GTH pseudopotentials are taken from the /data directory of the CP2K repository . This project is developed using Python 3 , numpy and h5py (for the storage). The webserver is powered by flask . This documentation is built using mkdocs . If you are interested in that, maybe you want to help? If so, I'm happy to welcome your contributions !","title":"How?"},{"location":"about/#who","text":"My name is Pierre Beaujean , and I'm a Ph.D. in quantum chemistry from the University of Namur (Belgium). I'm the main (and only) developer of this project, used in our lab. I use CP2K in the frame of my post-doctoral research, and I developed this project for all the reasons listed above.","title":"Who?"},{"location":"developers/bs_and_pseudo_file_format/","text":"Basis sets and GTH pseudopotential files format in CP2K \u00a4 To be continued, but See there for the basis sets, and there for the pseudopontials.","title":"Basis sets and pseudopotentials files format in CP2K"},{"location":"developers/bs_and_pseudo_file_format/#basis-sets-and-gth-pseudopotential-files-format-in-cp2k","text":"To be continued, but See there for the basis sets, and there for the pseudopontials.","title":"Basis sets and GTH pseudopotential files format in CP2K"},{"location":"developers/install/","text":"Install and contribute \u00a4 Install and run (simple version) \u00a4 First, install node. It is recommended to use nvm to do so. Then: # clone git clone https://github.com/pierre-24/cp2k-basis.git cd cp2k-basis # optional (but recommended): create virtualenv python -m venv virtualenv source venv/bin/activate # install dependencies make install make install-front # build front make front # run the webservice: # either: make run # or, flask --app cp2k_basis_webservice run If you want to use your own library of basis and pseudopotentials, check out this page , and then: # create an instance folder # see https://flask.palletsprojects.com/en/latest/config/#instance-folders mkdir instance # copy source cp library/DATA_SOURCES.yml instance/ # after editing the DATA_SOURCES.yml file to fit your needs, # run the `cb_fetch_data` command to create a new library: cb_fetch_data instance/DATA_SOURCES.yml -o instance/library.h5 # setup a custom config echo \"LIBRARY='instance/library.h5'\" > instance/settings.py And then you can restart the webservice. Contribute \u00a4 Contributions, either with issues or pull requests are welcomed. Install \u00a4 If you want to contribute, this is the usual deal: start by forking , then clone your fork and use the following install procedure instead. cd cp2k-basis # definitely recommended in this case: use a virtualenv! python -m venv virtualenv source venv/bin/activate # install also dev dependencies pip install pip-tools make install-dev make install-front # ... then build front and run (see above) Tips to contribute \u00a4 A useful setting is to setup the webservice to use the (smaller) test library for development: mkdir instance echo \"LIBRARY='tests/LIBRARY_EXAMPLE.h5'\" > instance/settings.py The webservice should then be faster to start & reload. A good place to start is the list of issues . In fact, it is easier if you start by filling an issue, and if you want to work on it, says so there, so that everyone knows that the issue is handled. Don't forget to work on a separate branch. Since this project follow the git flow , you should base your branch on dev , not work in it directly: git checkout -b new_branch origin/dev Don't forget to regularly run the linting and tests: make lint make test Indeed, the code follows the PEP-8 style recommendations , checked by flake8 , for the python part and use jshint for the JS part. Having an extensive test suite is also a good idea to prevent regressions. If you modify the front (i.e., the JS script file or the stylesheet), don't forget to rebuild the front to see the effects: make front Indeed, both JS and SCSS are minified. If you want to see and edit the doc, you can run the mkdocs webserver: make doc-serve Pull requests should be unitary, and include unit test(s) and documentation if needed. The test suite and lint must succeed for the merge request to be accepted.","title":"Install and contribute"},{"location":"developers/install/#install-and-contribute","text":"","title":"Install and contribute"},{"location":"developers/install/#install-and-run-simple-version","text":"First, install node. It is recommended to use nvm to do so. Then: # clone git clone https://github.com/pierre-24/cp2k-basis.git cd cp2k-basis # optional (but recommended): create virtualenv python -m venv virtualenv source venv/bin/activate # install dependencies make install make install-front # build front make front # run the webservice: # either: make run # or, flask --app cp2k_basis_webservice run If you want to use your own library of basis and pseudopotentials, check out this page , and then: # create an instance folder # see https://flask.palletsprojects.com/en/latest/config/#instance-folders mkdir instance # copy source cp library/DATA_SOURCES.yml instance/ # after editing the DATA_SOURCES.yml file to fit your needs, # run the `cb_fetch_data` command to create a new library: cb_fetch_data instance/DATA_SOURCES.yml -o instance/library.h5 # setup a custom config echo \"LIBRARY='instance/library.h5'\" > instance/settings.py And then you can restart the webservice.","title":"Install and run (simple version)"},{"location":"developers/install/#contribute","text":"Contributions, either with issues or pull requests are welcomed.","title":"Contribute"},{"location":"developers/install/#install","text":"If you want to contribute, this is the usual deal: start by forking , then clone your fork and use the following install procedure instead. cd cp2k-basis # definitely recommended in this case: use a virtualenv! python -m venv virtualenv source venv/bin/activate # install also dev dependencies pip install pip-tools make install-dev make install-front # ... then build front and run (see above)","title":"Install"},{"location":"developers/install/#tips-to-contribute","text":"A useful setting is to setup the webservice to use the (smaller) test library for development: mkdir instance echo \"LIBRARY='tests/LIBRARY_EXAMPLE.h5'\" > instance/settings.py The webservice should then be faster to start & reload. A good place to start is the list of issues . In fact, it is easier if you start by filling an issue, and if you want to work on it, says so there, so that everyone knows that the issue is handled. Don't forget to work on a separate branch. Since this project follow the git flow , you should base your branch on dev , not work in it directly: git checkout -b new_branch origin/dev Don't forget to regularly run the linting and tests: make lint make test Indeed, the code follows the PEP-8 style recommendations , checked by flake8 , for the python part and use jshint for the JS part. Having an extensive test suite is also a good idea to prevent regressions. If you modify the front (i.e., the JS script file or the stylesheet), don't forget to rebuild the front to see the effects: make front Indeed, both JS and SCSS are minified. If you want to see and edit the doc, you can run the mkdocs webserver: make doc-serve Pull requests should be unitary, and include unit test(s) and documentation if needed. The test suite and lint must succeed for the merge request to be accepted.","title":"Tips to contribute"},{"location":"developers/library_build/","text":"Building, using and improving the library \u00a4 This page describes how to manipulate the library of basis sets and pseudopotentials. Building the library (with cb_fetch_data ) \u00a4 Creating a library from the YAML source file \u00a4 Info The current library and the source YAML file are available here . From an existing YAML source file DATA_SOURCE.yml with the format described below, just use cb_fetch_data DATA_SOURCES.yml -o library.h5 This will create a library.h5 file , which might be exploited latter on . If you want to have insight on what is happening, you might want to use: LOGLEVEL = INFO cb_fetch_data DATA_SOURCES.yml -o library.h5 which is more verbose. Description of the YAML source file format \u00a4 Repositories \u00a4 Building the library requires a YAML file which describe all the sources for the basis sets and pseudopotentials . It is composed of: repositories : # list of repositories metadata : # metadata for each basis set and pseud The first item is a list of repositories. A repository is defined by a base url ( base ), which is a template. Keyword inside curly braces will be replaced by their value given in the keyword dictionary (following the Python format() syntax ). Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' the base URL will be https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/ . Then, ach repository has different files (listed files ). Files \u00a4 Each file is described using the following structure: name : <NAME> type : BASIS_SETS family_name : # dictionary (mandatory) variant : # dictionary (mandatory) Each file has a name and a type linked to its content, which is either BASIS_SETS or POTENTIALS . While gathering the file, cb_fetch_data will download it from <BASE_URL>/<NAME> . Example From the following structure: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS The URL https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/BASIS_MOLOPT will be used to fetch the file. Note It is possible to apply a patch (in the unified diff format ) by adding a patch option, whose value should be a path (relative to the directory where the YAML file is) to a patch file. This is useful to correct small inconsistencies or mistake. Sorting out the content of the file \u00a4 As you can see if you check out a file in the CP2K data/ folder , each file contains different basis sets (or pseudopotential) for different atom, so one should help cb_fetch_data to sort out everything. There are definition for each atom, followed by nicknames which indicates which basis set/pseudopotential this is. There may be multiple nickname, though there is usually two, of the form <name> <name>-qX , where <name> is the family name and the -qX variant indicate the number of valence electrons . Example In, e.g., BASIS_MOLOPT , one has: H SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q1 # ... H DZVP-MOLOPT-GTH DZVP-MOLOPT-GTH-q1 # ... H TZVP-MOLOPT-GTH TZVP-MOLOPT-GTH-q1 # ... C SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q4 # ... From the nicknames cb_fetch_data should figure out in which family (i.e., the basis set or pseudopotential) it will store this definition. Since the naming is not systematic (not always of the form <name>-qX ), one has to resort to a heavier tool which can show some flexibility. Thus, this is performed thanks to the family_name dictionary, which contains a REGEX as the key and a replacement as the value. All the nickname are checked against the REGEX, in the order given in the file. If a REGEX matches, then the search stops and: If the replacement is ~ (the null value in YAML), the name is discarted Otherwise, the replacement is yield, using pattern.replace(name, replacement) If at the end, no REGEX matches, the name is just discarded. Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' cb_fetch_data will apply the REGEX to every nickname, and will end up with a list of family names. With SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q1 , the result will be in both cases SZV-MOLOPT-GTH . Then, the variant dictionary is used to determine the variant (i.e., the number of valence electron, in the form qXX ) from the nicknames. The rules are the same as with family_name , but only the first result will be used. Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' cb_fetch_data will apply the REGEX to every nickname, and will take the first result. With SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q1 , the first nickname yield no result, while the second yield q1 , which will be used. Adding metadata \u00a4 Finaly, cb_fetch_data , it will add metadata to those families. To do so, the metdata dictionary will be used, in which the key is a REGEX matched against the name of the family. The if there is a match, then all the values are attributed as metadata. Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' metadata : '^SZV-MOLOPT-GTH$' : references : [ https : //github.com/cp2k/cp2k-data ] description : A double zeta basis set '.*' : references : [ https : //github.com/cp2k/cp2k-data ] description : MOLOPT basis set. For the basis set SZV-MOLOPT-GTH , the metadata will contain two fields: references and description (which will contain \"A double zeta basis set\") For the basis set DZVP-MOLOPT-GTH (or any other basis, thanks to the use of .* ), the fields in the metadata will be the same, but the value of description is different (\"MOLOPT basis set.\"). For the moment, references , description and kind are the three metadata that should be reported for every basis set and pseudopotential. Note In practice, the YAML format defines anchors and aliases , which allow to define references and kinds once and use them multiple time. Using the library \u00a4 Info If you want to know how the basis sets and pseudopotentials are actually stored in the library file, check out this page . Currently, the web interface is the easiest way to query the library. However, you can have a quick overview of the content of the library using: cb_explore_library library.h5 You can also use the cp2k_basis library developed for this project. Example See there for some of Python code to access the library and query its content. Improving the library \u00a4 To improve the library, it might be easier to work directly with the file in question. This is possible with the cb_explore_file command. It takes a source YAML containing a list of files as an input, so that you can experiment before actually updating the library. An example: adding BASIS_MOLOPT_UCL \u00a4 Issue #6 requested the addtion of BASIS_MOLOPT_UCL to the library. This will be used as an example. First of all, download the file (notice the /raw/ ): wget https://github.com/cp2k/cp2k/raw/master/data/BASIS_MOLOPT_UCL Then create a source.yml file: touch source.yml This file will follow the same syntax as the one described above for files , so the following skeleton can be used files : - name : BASIS_MOLOPT_UCL type : BASIS_SETS family_name : variant : metadata : You can now run cb_explore_file ... But nothing much happens: $ cb_explore_file source.yml * | +- basis_sets | * | +- pseudopotentials | Indeed, after it has read source.yml , the program reports the content it has extracted, which is in that case nothing. This is normal: as described above , if no rule matches the nickname, they are just discarded. This is the case here, since there is no rule. Hopefully, the solution in this case is pretty straightforward: the name can be easily extracted from nicknames such as TZVP-MOLOPT-SR-GTH-q3 , and so is the variant. Example With the following source.yml , files : - name : BASIS_MOLOPT_UCL type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' metadata : The result is better: $ cb_explore_file source.yml * | +- basis_sets | +- TZVP-MOLOPT-SR-GTH | metadata={'source': 'BASIS_MOLOPT_UCL'} | | | +- Li: q3 | +- Be: q4 (...) The following basis sets were extracted: $ cb_explore_file source.yml | grep \" +-\" +- TZVP-MOLOPT-SR-GTH +- TZV2P-MOLOPT-SR-GTH +- DZVPd-MOLOPT-SR-GTH +- TZVPd-MOLOPT-SR-GTH +- TZV2Pd-MOLOPT-SR-GTH +- SZV-MOLOPT-SR-GTH +- DZVP-MOLOPT-SR-GTH +- SZV-MOLOPT-GTH +- DZVP-MOLOPT-GTH +- TZVP-MOLOPT-GTH +- TZV2P-MOLOPT-GTH +- TZV2PX-MOLOPT-GTH +- DZV-MOLOPT-SR-GTH Now you just need to add the metadata and iterate on the result until you are happy. Example With the following source.yml , files : - name : BASIS_MOLOPT_UCL type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' metadata : '^TZVP-MOLOPT-SR-GTH$' : references : [ https : //github.com/cp2k/cp2k-data ] description : Short-range triple zeta (+ polarization) basis set. kind : [ MOLOPT , SR , GTH ] Metadata were added to the basis sets: $ cb_explore_file source.yml * | +- basis_sets | +- TZVP-MOLOPT-SR-GTH | metadata={'references': ['https://github.com/cp2k/cp2k-data'], 'description': 'Short-range triple zeta (+ polarization) basis set.', 'kind': ['MOLOPT', 'SR', 'GTH']} | | | +- Li: q3 | +- Be: q4 (...) When you are happy with the result (metadata should be defined for all basis sets!), you can add it to the main DATA_SOURCES.yml and do a pull request.","title":"Build, use and improve the library"},{"location":"developers/library_build/#building-using-and-improving-the-library","text":"This page describes how to manipulate the library of basis sets and pseudopotentials.","title":"Building, using and improving the library"},{"location":"developers/library_build/#building-the-library-with-cb_fetch_data","text":"","title":"Building the library (with cb_fetch_data)"},{"location":"developers/library_build/#creating-a-library-from-the-yaml-source-file","text":"Info The current library and the source YAML file are available here . From an existing YAML source file DATA_SOURCE.yml with the format described below, just use cb_fetch_data DATA_SOURCES.yml -o library.h5 This will create a library.h5 file , which might be exploited latter on . If you want to have insight on what is happening, you might want to use: LOGLEVEL = INFO cb_fetch_data DATA_SOURCES.yml -o library.h5 which is more verbose.","title":"Creating a library from the YAML source file"},{"location":"developers/library_build/#description-of-the-yaml-source-file-format","text":"","title":"Description of the YAML source file format"},{"location":"developers/library_build/#repositories","text":"Building the library requires a YAML file which describe all the sources for the basis sets and pseudopotentials . It is composed of: repositories : # list of repositories metadata : # metadata for each basis set and pseud The first item is a list of repositories. A repository is defined by a base url ( base ), which is a template. Keyword inside curly braces will be replaced by their value given in the keyword dictionary (following the Python format() syntax ). Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' the base URL will be https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/ . Then, ach repository has different files (listed files ).","title":"Repositories"},{"location":"developers/library_build/#files","text":"Each file is described using the following structure: name : <NAME> type : BASIS_SETS family_name : # dictionary (mandatory) variant : # dictionary (mandatory) Each file has a name and a type linked to its content, which is either BASIS_SETS or POTENTIALS . While gathering the file, cb_fetch_data will download it from <BASE_URL>/<NAME> . Example From the following structure: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS The URL https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/BASIS_MOLOPT will be used to fetch the file. Note It is possible to apply a patch (in the unified diff format ) by adding a patch option, whose value should be a path (relative to the directory where the YAML file is) to a patch file. This is useful to correct small inconsistencies or mistake.","title":"Files"},{"location":"developers/library_build/#sorting-out-the-content-of-the-file","text":"As you can see if you check out a file in the CP2K data/ folder , each file contains different basis sets (or pseudopotential) for different atom, so one should help cb_fetch_data to sort out everything. There are definition for each atom, followed by nicknames which indicates which basis set/pseudopotential this is. There may be multiple nickname, though there is usually two, of the form <name> <name>-qX , where <name> is the family name and the -qX variant indicate the number of valence electrons . Example In, e.g., BASIS_MOLOPT , one has: H SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q1 # ... H DZVP-MOLOPT-GTH DZVP-MOLOPT-GTH-q1 # ... H TZVP-MOLOPT-GTH TZVP-MOLOPT-GTH-q1 # ... C SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q4 # ... From the nicknames cb_fetch_data should figure out in which family (i.e., the basis set or pseudopotential) it will store this definition. Since the naming is not systematic (not always of the form <name>-qX ), one has to resort to a heavier tool which can show some flexibility. Thus, this is performed thanks to the family_name dictionary, which contains a REGEX as the key and a replacement as the value. All the nickname are checked against the REGEX, in the order given in the file. If a REGEX matches, then the search stops and: If the replacement is ~ (the null value in YAML), the name is discarted Otherwise, the replacement is yield, using pattern.replace(name, replacement) If at the end, no REGEX matches, the name is just discarded. Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' cb_fetch_data will apply the REGEX to every nickname, and will end up with a list of family names. With SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q1 , the result will be in both cases SZV-MOLOPT-GTH . Then, the variant dictionary is used to determine the variant (i.e., the number of valence electron, in the form qXX ) from the nicknames. The rules are the same as with family_name , but only the first result will be used. Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' cb_fetch_data will apply the REGEX to every nickname, and will take the first result. With SZV-MOLOPT-GTH SZV-MOLOPT-GTH-q1 , the first nickname yield no result, while the second yield q1 , which will be used.","title":"Sorting out the content of the file"},{"location":"developers/library_build/#adding-metadata","text":"Finaly, cb_fetch_data , it will add metadata to those families. To do so, the metdata dictionary will be used, in which the key is a REGEX matched against the name of the family. The if there is a match, then all the values are attributed as metadata. Example With: repositories : - base : https://github.com/cp2k/cp2k/raw/{commit}/data/ data : commit : '786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1' files : - name : BASIS_MOLOPT type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' metadata : '^SZV-MOLOPT-GTH$' : references : [ https : //github.com/cp2k/cp2k-data ] description : A double zeta basis set '.*' : references : [ https : //github.com/cp2k/cp2k-data ] description : MOLOPT basis set. For the basis set SZV-MOLOPT-GTH , the metadata will contain two fields: references and description (which will contain \"A double zeta basis set\") For the basis set DZVP-MOLOPT-GTH (or any other basis, thanks to the use of .* ), the fields in the metadata will be the same, but the value of description is different (\"MOLOPT basis set.\"). For the moment, references , description and kind are the three metadata that should be reported for every basis set and pseudopotential. Note In practice, the YAML format defines anchors and aliases , which allow to define references and kinds once and use them multiple time.","title":"Adding metadata"},{"location":"developers/library_build/#using-the-library","text":"Info If you want to know how the basis sets and pseudopotentials are actually stored in the library file, check out this page . Currently, the web interface is the easiest way to query the library. However, you can have a quick overview of the content of the library using: cb_explore_library library.h5 You can also use the cp2k_basis library developed for this project. Example See there for some of Python code to access the library and query its content.","title":"Using the library"},{"location":"developers/library_build/#improving-the-library","text":"To improve the library, it might be easier to work directly with the file in question. This is possible with the cb_explore_file command. It takes a source YAML containing a list of files as an input, so that you can experiment before actually updating the library.","title":"Improving the library"},{"location":"developers/library_build/#an-example-adding-basis_molopt_ucl","text":"Issue #6 requested the addtion of BASIS_MOLOPT_UCL to the library. This will be used as an example. First of all, download the file (notice the /raw/ ): wget https://github.com/cp2k/cp2k/raw/master/data/BASIS_MOLOPT_UCL Then create a source.yml file: touch source.yml This file will follow the same syntax as the one described above for files , so the following skeleton can be used files : - name : BASIS_MOLOPT_UCL type : BASIS_SETS family_name : variant : metadata : You can now run cb_explore_file ... But nothing much happens: $ cb_explore_file source.yml * | +- basis_sets | * | +- pseudopotentials | Indeed, after it has read source.yml , the program reports the content it has extracted, which is in that case nothing. This is normal: as described above , if no rule matches the nickname, they are just discarded. This is the case here, since there is no rule. Hopefully, the solution in this case is pretty straightforward: the name can be easily extracted from nicknames such as TZVP-MOLOPT-SR-GTH-q3 , and so is the variant. Example With the following source.yml , files : - name : BASIS_MOLOPT_UCL type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' metadata : The result is better: $ cb_explore_file source.yml * | +- basis_sets | +- TZVP-MOLOPT-SR-GTH | metadata={'source': 'BASIS_MOLOPT_UCL'} | | | +- Li: q3 | +- Be: q4 (...) The following basis sets were extracted: $ cb_explore_file source.yml | grep \" +-\" +- TZVP-MOLOPT-SR-GTH +- TZV2P-MOLOPT-SR-GTH +- DZVPd-MOLOPT-SR-GTH +- TZVPd-MOLOPT-SR-GTH +- TZV2Pd-MOLOPT-SR-GTH +- SZV-MOLOPT-SR-GTH +- DZVP-MOLOPT-SR-GTH +- SZV-MOLOPT-GTH +- DZVP-MOLOPT-GTH +- TZVP-MOLOPT-GTH +- TZV2P-MOLOPT-GTH +- TZV2PX-MOLOPT-GTH +- DZV-MOLOPT-SR-GTH Now you just need to add the metadata and iterate on the result until you are happy. Example With the following source.yml , files : - name : BASIS_MOLOPT_UCL type : BASIS_SETS family_name : '^(.*)(-q\\d{1,2})$' : '\\1' variant : '^.*-(q\\d{1,2})$' : '\\1' metadata : '^TZVP-MOLOPT-SR-GTH$' : references : [ https : //github.com/cp2k/cp2k-data ] description : Short-range triple zeta (+ polarization) basis set. kind : [ MOLOPT , SR , GTH ] Metadata were added to the basis sets: $ cb_explore_file source.yml * | +- basis_sets | +- TZVP-MOLOPT-SR-GTH | metadata={'references': ['https://github.com/cp2k/cp2k-data'], 'description': 'Short-range triple zeta (+ polarization) basis set.', 'kind': ['MOLOPT', 'SR', 'GTH']} | | | +- Li: q3 | +- Be: q4 (...) When you are happy with the result (metadata should be defined for all basis sets!), you can add it to the main DATA_SOURCES.yml and do a pull request.","title":"An example: adding BASIS_MOLOPT_UCL"},{"location":"developers/library_content/","text":"Content of the library \u00a4 The following files are used to build the current library : Basis sets: ALL_BASIS_SETS BASIS_MOLOPT BASIS_MOLOPT_AcPP1 BASIS_MOLOPT_LnPP1 BASIS_MOLOPT_UCL BASIS_MOLOPT_UZH GTH_BASIS_SETS Potentials: GTH_POTENTIALS LnPP1_POTENTIALS AcPP1_POTENTIALS POTENTIAL_UZH","title":"Content of the library"},{"location":"developers/library_content/#content-of-the-library","text":"The following files are used to build the current library : Basis sets: ALL_BASIS_SETS BASIS_MOLOPT BASIS_MOLOPT_AcPP1 BASIS_MOLOPT_LnPP1 BASIS_MOLOPT_UCL BASIS_MOLOPT_UZH GTH_BASIS_SETS Potentials: GTH_POTENTIALS LnPP1_POTENTIALS AcPP1_POTENTIALS POTENTIAL_UZH","title":"Content of the library"},{"location":"developers/library_file_format/","text":"The library.h5 file format \u00a4 Info A library file is in the HDF5 format , which divide the data in groups (i.e., \"folders\") and datasets (i.e., \"files\"), the latter being array of data. Groups and datasets can have attributes. The basis set library root contains at least two main (storage) groups: basis_sets and pseudopotentials . They are detailed below. The basis_sets group \u00a4 This group contains one subgroup per basis set (a basis set group), for which the name is the basis set name. In each basis set group, there is one subgroup for each atom (a atomic bs group). Finally, in that atomic bs subgroup, there is one atomic bs variant group for each variant. Thus, the following structure is valid: * | +- basis_sets/ # `basis_sets` group | +- SZV-MOLOPT-GTH/ # a `basis set` group | | | +- C/ # an `atomic bs` group | | | | | +- q4/ # an `atomic bs variant` group (see below) | | | +- H/ | | | | | +- q1/ | | | +- ... | +- DZVP-MOLOPT-GTH/ | +- C/ | | | +- q4/ | +- H/ | | | +- q1/ | +- ... Each atomic bs variant group is composed of the following datasets, which are all mandatory: Name Shape Attributes Info info (2,) --- contains (len(names), len(contractions)) names (n,) --- contains n=len(names) names contraction_{i}_info (4+n,) nshell [mandatory] contains (principle_n, l_min, l_max, nfunc, nshell[0], ..., nshell[n-1]) with n=attrs[nshell] contraction_{i}_exp_coefs (nfunc,1+sum(nshell)) --- contains exponents in [:, 0] and coefficients in [:, 1:] The two last datasets are repeated with i=[0:len(contractions)] . Thus, the following structure, e.g., is valid: * | + basis_sets/TZVP-GTH/C/q4/ # contains two contractions | +- info # contains (2, 2) +- names # contains (TZVP-GTH-q4, TZVP-GTH) +- contraction_0_info # contains (2, 0, 1, 5, 3, 3) | # and has attribute nshell=2 +- contraction_0_exp_coefs # of shape (5, 7) +- contraction_1_info # contains (3, 2, 2, 1, 1) | # and has attribute nshell=1 +- contraction_1_exp_coefs # of shape (1, 2) The pseudopotentials group \u00a4 Again, this group contains one subgroup per pseudopotential familly (a pp family group), which name is the family name. In each pp family group, there is one subgroup for each basis set (a atomic pp group). Finally, in that atomic pp subgroup, there is one atomic pp variant group for each variant. Thus, the following structure is valid: * | +- pseudopotentials/ # the `pseudopotentials` group | +- GTH-BLYP/ # a `pp family group` | | | +- C/ # an `atomic pp` group | | | | | +- q4/ # an `atomic pp variant` group (see below) | | | +- H/ | | | | | +- q1/ | | | +- ... | +- GTH-PBE/ | +- C/ | | | +- q4/ | +- ... Each atomic pp variant group is composed of the following datasets, which are all mandatory: Name Shape Attributes Info info (3+n,) nelec [mandatory] contains (len(names), len(lcoefs), len(nlprojectors), nelec[0], ... nelec[n-1]) with n=attrs[nelec] names (n,) --- contains n=len(names) names local_radius_coefs (1+n,) --- contains (lradius, lcoef[0],..., lcoefs[n-1]) with n=len(lcoefs) nlprojector_{i}_radius_coefs (1+n,) nfunc [mandatory] contains (nlradius, nlcoefs[triu(n)[0]], ..., nlcoefs[triu(n)[n-1]]) with n=attrs[nfunc] and triu(N) gives the list of the upper triangular indices of a square matrix of size N . The last dataset is repeated with i=[0:len(nlprojectors)] . The following structure, e.g., is valid: * | +- pseudopotentials/GTH-BLYP/Ne/q8/ | +- info # contains (2, 2, 2, 2, 6) | # and has attribute nelec=2 +- names # contains (GTH-BLYP-q8, GTH-BLYP) +- local_radius_coefs # of shape (3,) +- nlprojector_0_radius_coefs # of shape (4,) | # and has attribute nfunc=2 +- nlprojector_1_radius_coefs # of shape (2,) # and has attribute nfunc=1 Metadata \u00a4 The file may have the date_build attribute, indicating when it was created. Each basis set and pp familly group might also have the following attributes: Name Type Description description str Description of the data references array One-dimensional array of URLs to reference papers (DOI) or sources. kind array One-dimensional array of kinds Each atomic bs variant and atomic pp variant may present a source attribute which indicate the URL to the source of this variant. Those attributes are optional.","title":"Library file format"},{"location":"developers/library_file_format/#the-libraryh5-file-format","text":"Info A library file is in the HDF5 format , which divide the data in groups (i.e., \"folders\") and datasets (i.e., \"files\"), the latter being array of data. Groups and datasets can have attributes. The basis set library root contains at least two main (storage) groups: basis_sets and pseudopotentials . They are detailed below.","title":"The library.h5 file format"},{"location":"developers/library_file_format/#the-basis_sets-group","text":"This group contains one subgroup per basis set (a basis set group), for which the name is the basis set name. In each basis set group, there is one subgroup for each atom (a atomic bs group). Finally, in that atomic bs subgroup, there is one atomic bs variant group for each variant. Thus, the following structure is valid: * | +- basis_sets/ # `basis_sets` group | +- SZV-MOLOPT-GTH/ # a `basis set` group | | | +- C/ # an `atomic bs` group | | | | | +- q4/ # an `atomic bs variant` group (see below) | | | +- H/ | | | | | +- q1/ | | | +- ... | +- DZVP-MOLOPT-GTH/ | +- C/ | | | +- q4/ | +- H/ | | | +- q1/ | +- ... Each atomic bs variant group is composed of the following datasets, which are all mandatory: Name Shape Attributes Info info (2,) --- contains (len(names), len(contractions)) names (n,) --- contains n=len(names) names contraction_{i}_info (4+n,) nshell [mandatory] contains (principle_n, l_min, l_max, nfunc, nshell[0], ..., nshell[n-1]) with n=attrs[nshell] contraction_{i}_exp_coefs (nfunc,1+sum(nshell)) --- contains exponents in [:, 0] and coefficients in [:, 1:] The two last datasets are repeated with i=[0:len(contractions)] . Thus, the following structure, e.g., is valid: * | + basis_sets/TZVP-GTH/C/q4/ # contains two contractions | +- info # contains (2, 2) +- names # contains (TZVP-GTH-q4, TZVP-GTH) +- contraction_0_info # contains (2, 0, 1, 5, 3, 3) | # and has attribute nshell=2 +- contraction_0_exp_coefs # of shape (5, 7) +- contraction_1_info # contains (3, 2, 2, 1, 1) | # and has attribute nshell=1 +- contraction_1_exp_coefs # of shape (1, 2)","title":"The basis_sets group"},{"location":"developers/library_file_format/#the-pseudopotentials-group","text":"Again, this group contains one subgroup per pseudopotential familly (a pp family group), which name is the family name. In each pp family group, there is one subgroup for each basis set (a atomic pp group). Finally, in that atomic pp subgroup, there is one atomic pp variant group for each variant. Thus, the following structure is valid: * | +- pseudopotentials/ # the `pseudopotentials` group | +- GTH-BLYP/ # a `pp family group` | | | +- C/ # an `atomic pp` group | | | | | +- q4/ # an `atomic pp variant` group (see below) | | | +- H/ | | | | | +- q1/ | | | +- ... | +- GTH-PBE/ | +- C/ | | | +- q4/ | +- ... Each atomic pp variant group is composed of the following datasets, which are all mandatory: Name Shape Attributes Info info (3+n,) nelec [mandatory] contains (len(names), len(lcoefs), len(nlprojectors), nelec[0], ... nelec[n-1]) with n=attrs[nelec] names (n,) --- contains n=len(names) names local_radius_coefs (1+n,) --- contains (lradius, lcoef[0],..., lcoefs[n-1]) with n=len(lcoefs) nlprojector_{i}_radius_coefs (1+n,) nfunc [mandatory] contains (nlradius, nlcoefs[triu(n)[0]], ..., nlcoefs[triu(n)[n-1]]) with n=attrs[nfunc] and triu(N) gives the list of the upper triangular indices of a square matrix of size N . The last dataset is repeated with i=[0:len(nlprojectors)] . The following structure, e.g., is valid: * | +- pseudopotentials/GTH-BLYP/Ne/q8/ | +- info # contains (2, 2, 2, 2, 6) | # and has attribute nelec=2 +- names # contains (GTH-BLYP-q8, GTH-BLYP) +- local_radius_coefs # of shape (3,) +- nlprojector_0_radius_coefs # of shape (4,) | # and has attribute nfunc=2 +- nlprojector_1_radius_coefs # of shape (2,) # and has attribute nfunc=1","title":"The pseudopotentials group"},{"location":"developers/library_file_format/#metadata","text":"The file may have the date_build attribute, indicating when it was created. Each basis set and pp familly group might also have the following attributes: Name Type Description description str Description of the data references array One-dimensional array of URLs to reference papers (DOI) or sources. kind array One-dimensional array of kinds Each atomic bs variant and atomic pp variant may present a source attribute which indicate the URL to the source of this variant. Those attributes are optional.","title":"Metadata"},{"location":"users/api/","text":"REST API reference \u00a4 Info A public version is available at https://cp2k-basis.pierrebeaujean.net/api/ . Preamble \u00a4 Request \u00a4 This API can be used to retrieve two types ( <type> ) of data, either basis sets ( basis ) or pseudopotentials ( pseudopotentials ). Each of them has a name ( <name> ). Options are added as query string: /api/example?option1=value&option2=value . All routes are addressed by GET requests. On the elements option \u00a4 Every time the option elements can be used, you can use a list of comma separated atomic symbols, e.g., C,H,N,O , but also ranges, e.g., H,C-O , and Z numbers can be used instead of symbols, e,g., H,6-8 . Elements are limited to Z \u2264 103, i.e., hydrogen to Lawrencium. If you want to perform calculations outside this range, you probably have other problems on your plate than finding a basis set ;) Response format \u00a4 The response is in JSON, and always contains two main fields: { \"query\" : { \"type\" : \"TYPE\" , (...) }, \"result\" : { (...) } } query contains the request, to which result is the answer. In the following, fields will be detailed using the syntax for object attributes in JS, e.g., query.type . Routes \u00a4 /api/data \u00a4 Get, for basis sets and pseudopotentials, which elements are defined, and for each element, which basis set/pseudopotentials are defined. There is no option. Output: Field Type Description query.type string Always ALL result.basis_sets dictionary Contains three fields: build_date , which give the date at which the library was built, elements , which lists elements available for a given basis set, and kinds , which lists the kind for each basis set. result.pseudopotentials dictionary Contains three fields: build_date , which give the date at which the library was built, elements , which lists elements available for a given pseudopotential, and kinds , which lists the kind for each pseudopotential. Example : curl https://cp2k-basis.pierrebeaujean.net/api/data { \"query\" : { \"type\" : \"ALL\" }, \"result\" : { \"basis_sets\" : { \"build_date\" : \"2022-12-16T18:09:03.513403\" , \"elements\" : { \"DZVP-MOLOPT-GTH\" : [ \"C\" , \"H\" , (...) ], (...) }, \"kinds\" : { \"DZVP-MOLOPT-GTH\" : [ \"molopt\" , \"gth\" ], (...) } }, \"pseudopotentials\" : { \"build_date\" : \"2022-12-16T18:09:03.513403\" , \"elements\" : { \"GTH-BLYP\" : [ \"B\" , \"Be\" , (...) ] }, \"kinds\" : { (...) } } } } /api/names \u00a4 List all available basis set and pseudopotential names available, eventually for a set of elements. Options: Option Argument Description elements String Restrict the output to a subset of elements. bs_name String Restrict the output to a subset of basis sets containing the given name (case insensitive). bs_kind String Restrict the output to a subset of basis sets having the given kind. pp_name String Restrict the output to a subset of pseudopotentials containing the given name (case insensitive). pp_kind String Restrict the output to a subset of pseudopotentials having the given kind. Available kinds are listed there . Output: Field Type Description query.type string Always ALL query.elements list of string Value of the elements option, if provided result.basis_sets list of string List of basis set names available result.pseudopotentials list of string List of pseudopotential names available Example : curl 'https://cp2k-basis.pierrebeaujean.net/api/names?elements=Ti&pp_name=PBE&bs_kind=SR' { \"query\" : { \"elements\" : [ \"Ti\" ], \"type\" : \"ALL\" }, \"result\" : { \"basis_sets\" : [ \"DZVP-MOLOPT-SR-GTH\" , \"SZV-MOLOPT-SR-GTH\" , \"TZV2P-MOLOPT-SR-GTH\" , \"TZVP-MOLOPT-SR-GTH\" ], \"pseudopotentials\" : [ \"GTH-PBE\" , \"GTH-PBE0\" ] } } /api/<type>/<name>/data \u00a4 Obtain data in the CP2K format. Options: Option Argument Description elements String Restrict the output to a subset of elements. If some elements are not defined for this basis set/pseudopotential, a 404 is raised. header Boolean Add an header to result.data (default is true) Output: Field Type Description query.type string BASIS_SET or PSEUDOPOTENTIAL query.name string The name you requested query.elements list of string Value of the elements option, if provided result.data string The resulting basis set or pseudopotential, in CP2K format result.elements list of string Elements for which there is data (matches the option elements if set) result.variants dictionary For each element, dictionary containing all variants and the corresponding name to be used for such variant result.metadata dictionary Dictionary of metadata about this pseudopotential/basis set. See below for content. Example : curl https://cp2k-basis.pierrebeaujean.net/api/basis/SZV-MOLOPT-SR-GTH/data?elements = Rh { \"query\" : { \"elements\" : [ \"Rh\" ], \"name\" : \"SZV-MOLOPT-SR-GTH\" , \"type\" : \"BASIS_SET\" }, \"result\" : { \"data\" : \"# URL: http://127.0.0.1:5000/api/basis/SZV-MOLOPT-SR-GTH/data?elements=Rh\\n# BUILD: 16/12/2022 @ 19:38\\n# FETCHED: 19/12/2022 @ 14:36\\n# ---\\n# Rh [12s6p6d|2s1p1d]\\n# SOURCE: https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/BASIS_MOLOPT#L1244\\nRh SZV-MOLOPT-SR-GTH SZV-MOLOPT-SR-GTH-q17\\n1\\n2 0 2 6 2 1 1\\n 3.157817444361 0.760084070950 0.239207051701 -0.336193318541 -0.176446839307\\n 2.683291075925 -0.255650224037 -0.091067207483 0.373953992584 0.261743358411\\n 1.140786095845 -1.025626679377 -0.520689753906 0.300684698668 0.174717739794\\n 0.492081007160 -0.234415477939 -0.274976137245 0.141457244144 0.188746290944\\n 0.192543904978 0.046321838032 0.534686741279 0.007751787318 0.112894420897\\n 0.066486620394 0.135748106274 0.896548625743 0.000117823467 0.021703317232\\n# Rh [6s6p6d|1s1p1d]\\n# SOURCE: https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/BASIS_MOLOPT#L1262\\nRh SZV-MOLOPT-SR-GTH-q9\\n1\\n2 0 2 6 1 1 1\\n 3.902721449032 0.016652865171 -0.008699428728 -0.112417659954\\n 1.999830271997 -0.133395648426 0.046572987907 0.348017742874\\n 0.879887627395 0.373099930807 -0.153463590375 0.381775351795\\n 0.363794442257 0.298777744612 -0.052550610965 0.335875585916\\n 0.140096726529 -0.924610879301 0.949493319446 0.146687236468\\n 0.042562039477 -0.455102584336 0.423881871378 0.013082339937\\n\" , \"elements\" : [ \"Rh\" ], \"metadata\" : { \"description\" : \"A single zeta valence MOLOPT basis set, for solids (short-range) and GTH pseudopotentials\" , \"kind\" : [ \"MOLOPT\" , \"SR\" , \"GTH\" ], \"references\" : [ \"https://dx.doi.org/10.1063/1.2770708\" , \"https://doi.org/10.1039/B508541A\" , \"https://github.com/cp2k/cp2k-data\" ] }, \"variants\" : { \"Rh\" : { \"q17\" : \"SZV-MOLOPT-SR-GTH-q17\" , \"q9\" : \"SZV-MOLOPT-SR-GTH-q9\" } } } } /api/<type>/<name>/metadata \u00a4 Obtain metadata about a basis set or pseudopotential. There is no option. Output: Field Type Description query.type string BASIS_SET or PSEUDOPOTENTIAL query.name string The name you requested result.elements list of string Elements for which the basis set/pseudopotential are defined result.description string Small description. result.references list of string List of URL to articles or repositories result.kind list of string Kind of the basis set/pseudopotential Example : curl https://cp2k-basis.pierrebeaujean.net/api/pseudopotentials/GTH-BLYP/metadata { \"query\" : { \"name\" : \"GTH-BLYP\" , \"type\" : \"PSEUDOPOTENTIAL\" }, \"result\" : { \"description\" : \"GTH pseudopotentials, optimized for BLYP.\" , \"elements\" : [ \"Ag\" , \"Al\" , (...) ], \"kind\" : [ \"GTH\" ], \"references\" : [ \"https://dx.doi.org/10.1103/PhysRevB.54.1703\" , \"https://dx.doi.org/10.1103/PhysRevB.58.3641\" , \"https://dx.doi.org/10.1007/s00214-005-0655-y\" , \"https://github.com/cp2k/cp2k-data\" ] } }","title":"REST API reference"},{"location":"users/api/#rest-api-reference","text":"Info A public version is available at https://cp2k-basis.pierrebeaujean.net/api/ .","title":"REST API reference"},{"location":"users/api/#preamble","text":"","title":"Preamble"},{"location":"users/api/#request","text":"This API can be used to retrieve two types ( <type> ) of data, either basis sets ( basis ) or pseudopotentials ( pseudopotentials ). Each of them has a name ( <name> ). Options are added as query string: /api/example?option1=value&option2=value . All routes are addressed by GET requests.","title":"Request"},{"location":"users/api/#on-the-elements-option","text":"Every time the option elements can be used, you can use a list of comma separated atomic symbols, e.g., C,H,N,O , but also ranges, e.g., H,C-O , and Z numbers can be used instead of symbols, e,g., H,6-8 . Elements are limited to Z \u2264 103, i.e., hydrogen to Lawrencium. If you want to perform calculations outside this range, you probably have other problems on your plate than finding a basis set ;)","title":"On the elements option"},{"location":"users/api/#response-format","text":"The response is in JSON, and always contains two main fields: { \"query\" : { \"type\" : \"TYPE\" , (...) }, \"result\" : { (...) } } query contains the request, to which result is the answer. In the following, fields will be detailed using the syntax for object attributes in JS, e.g., query.type .","title":"Response format"},{"location":"users/api/#routes","text":"","title":"Routes"},{"location":"users/api/#apidata","text":"Get, for basis sets and pseudopotentials, which elements are defined, and for each element, which basis set/pseudopotentials are defined. There is no option. Output: Field Type Description query.type string Always ALL result.basis_sets dictionary Contains three fields: build_date , which give the date at which the library was built, elements , which lists elements available for a given basis set, and kinds , which lists the kind for each basis set. result.pseudopotentials dictionary Contains three fields: build_date , which give the date at which the library was built, elements , which lists elements available for a given pseudopotential, and kinds , which lists the kind for each pseudopotential. Example : curl https://cp2k-basis.pierrebeaujean.net/api/data { \"query\" : { \"type\" : \"ALL\" }, \"result\" : { \"basis_sets\" : { \"build_date\" : \"2022-12-16T18:09:03.513403\" , \"elements\" : { \"DZVP-MOLOPT-GTH\" : [ \"C\" , \"H\" , (...) ], (...) }, \"kinds\" : { \"DZVP-MOLOPT-GTH\" : [ \"molopt\" , \"gth\" ], (...) } }, \"pseudopotentials\" : { \"build_date\" : \"2022-12-16T18:09:03.513403\" , \"elements\" : { \"GTH-BLYP\" : [ \"B\" , \"Be\" , (...) ] }, \"kinds\" : { (...) } } } }","title":"/api/data"},{"location":"users/api/#apinames","text":"List all available basis set and pseudopotential names available, eventually for a set of elements. Options: Option Argument Description elements String Restrict the output to a subset of elements. bs_name String Restrict the output to a subset of basis sets containing the given name (case insensitive). bs_kind String Restrict the output to a subset of basis sets having the given kind. pp_name String Restrict the output to a subset of pseudopotentials containing the given name (case insensitive). pp_kind String Restrict the output to a subset of pseudopotentials having the given kind. Available kinds are listed there . Output: Field Type Description query.type string Always ALL query.elements list of string Value of the elements option, if provided result.basis_sets list of string List of basis set names available result.pseudopotentials list of string List of pseudopotential names available Example : curl 'https://cp2k-basis.pierrebeaujean.net/api/names?elements=Ti&pp_name=PBE&bs_kind=SR' { \"query\" : { \"elements\" : [ \"Ti\" ], \"type\" : \"ALL\" }, \"result\" : { \"basis_sets\" : [ \"DZVP-MOLOPT-SR-GTH\" , \"SZV-MOLOPT-SR-GTH\" , \"TZV2P-MOLOPT-SR-GTH\" , \"TZVP-MOLOPT-SR-GTH\" ], \"pseudopotentials\" : [ \"GTH-PBE\" , \"GTH-PBE0\" ] } }","title":"/api/names"},{"location":"users/api/#apitypenamedata","text":"Obtain data in the CP2K format. Options: Option Argument Description elements String Restrict the output to a subset of elements. If some elements are not defined for this basis set/pseudopotential, a 404 is raised. header Boolean Add an header to result.data (default is true) Output: Field Type Description query.type string BASIS_SET or PSEUDOPOTENTIAL query.name string The name you requested query.elements list of string Value of the elements option, if provided result.data string The resulting basis set or pseudopotential, in CP2K format result.elements list of string Elements for which there is data (matches the option elements if set) result.variants dictionary For each element, dictionary containing all variants and the corresponding name to be used for such variant result.metadata dictionary Dictionary of metadata about this pseudopotential/basis set. See below for content. Example : curl https://cp2k-basis.pierrebeaujean.net/api/basis/SZV-MOLOPT-SR-GTH/data?elements = Rh { \"query\" : { \"elements\" : [ \"Rh\" ], \"name\" : \"SZV-MOLOPT-SR-GTH\" , \"type\" : \"BASIS_SET\" }, \"result\" : { \"data\" : \"# URL: http://127.0.0.1:5000/api/basis/SZV-MOLOPT-SR-GTH/data?elements=Rh\\n# BUILD: 16/12/2022 @ 19:38\\n# FETCHED: 19/12/2022 @ 14:36\\n# ---\\n# Rh [12s6p6d|2s1p1d]\\n# SOURCE: https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/BASIS_MOLOPT#L1244\\nRh SZV-MOLOPT-SR-GTH SZV-MOLOPT-SR-GTH-q17\\n1\\n2 0 2 6 2 1 1\\n 3.157817444361 0.760084070950 0.239207051701 -0.336193318541 -0.176446839307\\n 2.683291075925 -0.255650224037 -0.091067207483 0.373953992584 0.261743358411\\n 1.140786095845 -1.025626679377 -0.520689753906 0.300684698668 0.174717739794\\n 0.492081007160 -0.234415477939 -0.274976137245 0.141457244144 0.188746290944\\n 0.192543904978 0.046321838032 0.534686741279 0.007751787318 0.112894420897\\n 0.066486620394 0.135748106274 0.896548625743 0.000117823467 0.021703317232\\n# Rh [6s6p6d|1s1p1d]\\n# SOURCE: https://github.com/cp2k/cp2k/raw/786bc82ff9ded3e1f761cba6d8e25c3c9fe19bb1/data/BASIS_MOLOPT#L1262\\nRh SZV-MOLOPT-SR-GTH-q9\\n1\\n2 0 2 6 1 1 1\\n 3.902721449032 0.016652865171 -0.008699428728 -0.112417659954\\n 1.999830271997 -0.133395648426 0.046572987907 0.348017742874\\n 0.879887627395 0.373099930807 -0.153463590375 0.381775351795\\n 0.363794442257 0.298777744612 -0.052550610965 0.335875585916\\n 0.140096726529 -0.924610879301 0.949493319446 0.146687236468\\n 0.042562039477 -0.455102584336 0.423881871378 0.013082339937\\n\" , \"elements\" : [ \"Rh\" ], \"metadata\" : { \"description\" : \"A single zeta valence MOLOPT basis set, for solids (short-range) and GTH pseudopotentials\" , \"kind\" : [ \"MOLOPT\" , \"SR\" , \"GTH\" ], \"references\" : [ \"https://dx.doi.org/10.1063/1.2770708\" , \"https://doi.org/10.1039/B508541A\" , \"https://github.com/cp2k/cp2k-data\" ] }, \"variants\" : { \"Rh\" : { \"q17\" : \"SZV-MOLOPT-SR-GTH-q17\" , \"q9\" : \"SZV-MOLOPT-SR-GTH-q9\" } } } }","title":"/api/&lt;type&gt;/&lt;name&gt;/data"},{"location":"users/api/#apitypenamemetadata","text":"Obtain metadata about a basis set or pseudopotential. There is no option. Output: Field Type Description query.type string BASIS_SET or PSEUDOPOTENTIAL query.name string The name you requested result.elements list of string Elements for which the basis set/pseudopotential are defined result.description string Small description. result.references list of string List of URL to articles or repositories result.kind list of string Kind of the basis set/pseudopotential Example : curl https://cp2k-basis.pierrebeaujean.net/api/pseudopotentials/GTH-BLYP/metadata { \"query\" : { \"name\" : \"GTH-BLYP\" , \"type\" : \"PSEUDOPOTENTIAL\" }, \"result\" : { \"description\" : \"GTH pseudopotentials, optimized for BLYP.\" , \"elements\" : [ \"Ag\" , \"Al\" , (...) ], \"kind\" : [ \"GTH\" ], \"references\" : [ \"https://dx.doi.org/10.1103/PhysRevB.54.1703\" , \"https://dx.doi.org/10.1103/PhysRevB.58.3641\" , \"https://dx.doi.org/10.1007/s00214-005-0655-y\" , \"https://github.com/cp2k/cp2k-data\" ] } }","title":"/api/&lt;type&gt;/&lt;name&gt;/metadata"},{"location":"users/basis_sets_and_pseudos/","text":"On basis sets and GTH pseudopotentials in CP2K \u00a4 Info For the latest CP2K review, see 10.1063/5.0007045 (May 2020). The GPW method is described, e.g., here . Basis sets \u00a4 Solving the Schr\u00f6dinger equation generally resort to the use of the LCAO ( linear combination of atomic orbitals ) approximation. For computational reasons, while STO (slater-type orbitals, \\(\\propto e^{r}\\) ) should be used, GTO (gaussian type orbitals, \\(\\propto e^{r^2}\\) ) are preferred. In CP2K (as in other quantum chemistry programs), basis functions (i.e., atomic orbitals) are defined as: \\[\\psi_{i,\\ell m} (\\mathbf r) = R_{i,\\ell}(\\mathbf r)\\,Y_{\\ell m}(\\theta,\\phi),\\] where \\(R(r)\\) is the radial part, and \\(Y_{\\ell m}\\) is a spherical harmonic ( \\(\\ell\\) is the angular momentum and \\(m\\in[-\\ell,\\ell]\\) ) for the angular part. A weighted sum of primitives (Gaussian functions) is used for this part: \\[R_{i,\\ell}(r) = r^\\ell\\,\\sum_{j} c_{ij}\\,e^{-\\alpha_j\\,r^2},\\] where \\(\\alpha_{j}\\) is the exponent , while \\(c_{ij}\\) is the corresponding contraction coefficient . The two numbers defines the primitive \\(j\\) in the basis function \\(\\psi_i\\) . Thus, a basis sets is a library of contractions for each shell (s-type [ \\(\\ell=0\\) ], p-type [ \\(\\ell=1\\) ], d-type [ \\(\\ell=2\\) ], etc) of a given atom, containing the definition of the primitives (so a list of exponents and their corresponding contraction coefficients). Since the radial part is the same for each possible orbital in a shell (i.e., each possible value of \\(m\\) ), this is sufficient to define a basis set. But basis function can be grouped! Some basis functions (even with different \\(\\ell\\) ) may be grouped to share the same exponent. This is the case, e.g., in the (in)famous STO-3G (3 gaussians for each basis function) in which so-called \"SP\" basis functions are found, defined by using a common exponent but different contraction coefficient for each of the 3 gaussians defining the actual s-type and p-type basis function. MOLOPT basis sets (see below) are built on this principle. Multiple- \\(\\zeta\\) basis sets use \\(\\zeta\\) basis functions for each atomic orbitals in the atom. For example, double- \\(\\zeta\\) basis sets use two basis function for each atomic orbital (e.g., a total of 10 basis function for the carbon). They may be grouped to share the same exponent, or not. On top of that, two other kind of basis function might be added: polarization functions , which have a larger angular momentum than those of the ground state of the atom (e.g., d-type basis functions for the carbon), and diffuse functions , which have very small exponents (corresponding to very \"large\" Gaussian functions). Thus, the number of basis function for a given atom is very different from one basis set to the other. Note One way to ease the communication is to report, for each shell, the number of primitives (uncontracted set) in the form (uncontracted set) , and the number of basis functions (contracted set) in the form [contracted set] . For example, in a double-zeta basis set defined by 3 gaussian per basis function, the result for carbn would be (12s,6p) and [3s,2p] . The form [12s6p|3s2p] , combining the two is also found. However, for reasons that will become clear in the next section, CP2K does not only use all-electron basis sets. GTH pseudopotentials \u00a4 Indeed, CP2K is able use an auxiliary plane wave (PW) basis set to perform its calculation with the GPW (and GAPW) method. To perform a such calculation, one needs to include all possible PW below a given threshold. In fact, increasing this threshold will monotonously improve the quality of the result (and the length of the calculation!). However, area where the electron density is rapidly changing requires PW with small wavelengths/high energy to be well described (i.e., large Fourier components), so high threshold, which would make the calculation impossible in practice. In practice, area where such changes are important are mostly located near the nuclei, \"thanks\" its ionic potential \\(V(r) = - \\frac{Z}{r}\\) . Hopefully, core and valence shell are generally well (spatially and energetically) separated, and core electrons are relatively unperturbed by the surrounding (chemically inert). So the idea behind pseudopotentials is to replace the effect of the nuclei and the core electrons (which are considered frozen ) by an effective potential (below a given threshold \\(r_c\\) ), and the valence electrons basis functions by ones with fewer nodes (since they do not need to be orthogonal to the, now removed, valence orbital), but with the same behavior outside the core region (for \\(r > r_c\\) ). Derivation of a pseudopotential Say one has a set of (orthogonal) core states \\(\\{|\\chi_n\\rangle\\}\\) (with their corresponding eigenvalue \\(\\{E_n\\}\\) ). The goal is to construct a pseudo-state \\(|\\phi\\rangle\\) for a valence state \\(|\\psi\\rangle\\) (with its corresponding eigenvalue \\(E\\) ), in the form: \\[|\\psi\\rangle = |\\phi\\rangle + \\sum_n a_n |\\chi_n\\rangle.\\] Since the core and valence state must be orthogonal, \\(\\langle \\chi_m | \\psi \\rangle = 0 = \\langle \\chi_m | \\phi \\rangle + a_m\\) , so that \\[|\\psi\\rangle = |\\phi\\rangle - \\sum_n |\\chi_n\\rangle \\langle \\chi_n | \\phi\\rangle.\\] Substituting in Schr\u00f6dinger equation for \\(|\\psi\\rangle\\) gives \\[\\hat H |\\phi\\rangle + \\sum_n (E-E_n) |\\chi_n\\rangle \\langle \\chi_n | \\phi\\rangle = E|\\phi\\rangle.\\] The pseudo-state thus obeys \\([\\hat H + \\hat V_{n\\ell}]\\, |\\phi\\rangle = E\\,|\\phi\\rangle\\) with: \\[\\hat V_{n\\ell} = \\sum_{n\\ell} (E-E_{n\\ell})\\,|\\chi_{n\\ell}\\rangle \\langle \\chi_{n\\ell} |.\\] where the energy of \\(|\\phi\\rangle\\) is the same as the one of \\(|\\psi\\rangle\\) , thanks to the pseudopotential \\(\\hat V_{n\\ell}\\) . This extra potential depends on the quantum numbers \\(n\\) and \\(\\ell\\) due to its spherical symmetry. Furthermore, since \\(E > E_{n\\ell}\\) , it is a repulsive potenial. In practice, pseudopotential expressions are separated into a fully nonlocal form, thanks to the Kleinman-Bylander Transformation (see 10.1103/PhysRevLett.48.1425 ). Latter on, Goedecker, Teter and Hutter (GTH, see 10.1103/PhysRevB.54.1703 ) derived expressions those two parts which are suited for real and Fourier space integration and only requires a few adjustable parameters (in blue): \\[\\hat V_{PP} = \\hat V_{loc} + \\sum_{\\ell}^{\\textcolor{blue}{\\ell_{max}}} \\hat V_{nl,\\ell},\\] with \\[V_{loc}(r) = -\\frac{Z'}{r}\\,\\text{erf}\\left[\\frac{\\bar r}{\\sqrt 2}\\right] + \\exp\\left[-\\frac{\\bar r^2}{2}\\right] \\sum_{i=1}^4 \\textcolor{blue}{C_i}\\,\\bar r^{2i-2}, \\text{ with } \\bar r = \\frac{r}{\\textcolor{blue}{r_c}},\\] and \\[V_{nl,\\ell} = \\sum_{ij}^{\\textcolor{blue}{N}} \\textcolor{blue}{h_{\\ell,ij}} \\,|p_{\\ell,i}\\rangle \\langle p_{\\ell,j}|, \\text{ with } p_{\\ell,i}(r) = N_{\\ell,i}(r)\\,\\exp\\left[-\\frac{\\bar r^2}{2}\\right] \\text{ and } \\bar r = \\frac{r}{\\textcolor{blue}{r_{nl,\\ell}}}.\\] In the former, \\(Z'\\) is the ionic charge (i.e., the charge of the nucleus minus the one of the core electrons), while in the latter, \\(N_\\ell(r)\\) is a combination of spherical harmonic multiplied by a \\(\\ell\\) -dependent radial function. All the parameters in blue, together with the number of core electrons in each shell, define a GTH pseudopotential in CP2K (see, e.g., 10.1007/s00214-005-0655-y ). In particular, they are given as a local part plus a set of nonlinear projectors. Note It is totally possible, for a given atom, to have pseudopotentials with a different number of core electrons embeded in the potential: while a small number of core electrons ensure a good transferability (but lengthen the calculation), a large number results in a smoother potential. Pairing GTH pseudopotentials with basis sets \u00a4 Warning In practice, the number electron is dictated by the pseudopotential (which lists the number of valence electrons in each shell). CP2K will blindly use whatever basis set you give, since it has no way to check the information on the basis set side (not even the names, which are merely conventions). From the previous paragraph, it appears that one has to pair a given pseudopotential with a correctly defined basis set, that has been designed with the correct amount of core electron removed and that contains smoother (pseudo-) basis functions. Names of pseudopotentials and basis sets help to achieve this association: GTH pseudopotential are generally named GTH-<XFC> , where <XCF> is the name of a XC-functional. It is thus strongly suggested to use them together with the XCF in question. For a given atom, such potentials are nicknamed GTH-<XFC>-q<N> , where <N> is the number of valence electrons considered while building the potential. For example, a pseudopotential for carbon is nicknamed GTH-BLYP-q4 , indicate that this pseudopotential was designed with BLYP, and that was built using 4 valence electrons (so it embedded a total of 2 core electrons). Basis sets are generally named <XZ>-<NAME>-<XCF>-GTH or <XZ>-GTH-<XCF> (though this is definitely not an absolute rule!), where <XZ> describe the content of the basis set (e.g., DZV for double zeta, TZVP for triple zeta with extra polarization, etc), <NAME> is the name of the family (e.g., MOLOPT ) and <XCF> is the name of the XCF used to optimize the basis set. The <XCF> may not be present in the name: for example, TZVP-MOLOPT-GTH should work with all XCF, while TZVP-MOLOPT-PBE-GTH was specifically designed with PBE. The latter probably gives better results and should (probably) be preferred. Again, for each atom, a suffix -q<N> is added, indicated how much valence electrons were not considered while building this basis set. For example, for carbon, the nickname DZVP-MOLOPT-GTH-q4 indicates that this is a double-zeta basis set (plus polarization functions) of the MOLOPT family, designed to work with GTH pseudopotentials embedding 2 core electrons. Where are the basis sets and GTH pseudopotentials? When running a CP2K calculation, you have to provide two files, containing the basis set(s) and pseudopotential(s) used in your calculation: &DFT BASIS_SET_FILE_NAME BASIS_SET POTENTIAL_FILE_NAME GTH_POTENTIALS &END DFT Basis sets and pseudopotentials are scattered across different file in the CP2K data folder . However, the web interface of this project proposes an easier way to build your own taylor-made BASIS_SET and GTH_POTENTIALS files. This is equivalent, since the data are obtained from the same source and just presented with a shiny interface ;) If you are interested, the format of those two files is described here Working with all-electron basis sets \u00a4 Info The GAPW method is introduced, e.g., here or in 10.1007/s002140050523 . There also exists a special pseudopotential, ALL , which should be used for all-electron calculations. This is the pseudopotential of choice for GAPW calculations. It can be used with your usual all-electron basis sets (such as STO-3G, e.g., found in the BSE ). A curated list is available in the EMSL_BASIS_SETS file . Specially designed basis sets were also derived (found, e.g., in the ALL_BASIS_SETS file ), which contains ALL in their name or ends by -ae . The -q<N> number, if it exists (it is generally omitted), should be equal to the atomic number.","title":"On basis sets and GTH pseudopotentials in CP2K"},{"location":"users/basis_sets_and_pseudos/#on-basis-sets-and-gth-pseudopotentials-in-cp2k","text":"Info For the latest CP2K review, see 10.1063/5.0007045 (May 2020). The GPW method is described, e.g., here .","title":"On basis sets and GTH pseudopotentials in CP2K"},{"location":"users/basis_sets_and_pseudos/#basis-sets","text":"Solving the Schr\u00f6dinger equation generally resort to the use of the LCAO ( linear combination of atomic orbitals ) approximation. For computational reasons, while STO (slater-type orbitals, \\(\\propto e^{r}\\) ) should be used, GTO (gaussian type orbitals, \\(\\propto e^{r^2}\\) ) are preferred. In CP2K (as in other quantum chemistry programs), basis functions (i.e., atomic orbitals) are defined as: \\[\\psi_{i,\\ell m} (\\mathbf r) = R_{i,\\ell}(\\mathbf r)\\,Y_{\\ell m}(\\theta,\\phi),\\] where \\(R(r)\\) is the radial part, and \\(Y_{\\ell m}\\) is a spherical harmonic ( \\(\\ell\\) is the angular momentum and \\(m\\in[-\\ell,\\ell]\\) ) for the angular part. A weighted sum of primitives (Gaussian functions) is used for this part: \\[R_{i,\\ell}(r) = r^\\ell\\,\\sum_{j} c_{ij}\\,e^{-\\alpha_j\\,r^2},\\] where \\(\\alpha_{j}\\) is the exponent , while \\(c_{ij}\\) is the corresponding contraction coefficient . The two numbers defines the primitive \\(j\\) in the basis function \\(\\psi_i\\) . Thus, a basis sets is a library of contractions for each shell (s-type [ \\(\\ell=0\\) ], p-type [ \\(\\ell=1\\) ], d-type [ \\(\\ell=2\\) ], etc) of a given atom, containing the definition of the primitives (so a list of exponents and their corresponding contraction coefficients). Since the radial part is the same for each possible orbital in a shell (i.e., each possible value of \\(m\\) ), this is sufficient to define a basis set. But basis function can be grouped! Some basis functions (even with different \\(\\ell\\) ) may be grouped to share the same exponent. This is the case, e.g., in the (in)famous STO-3G (3 gaussians for each basis function) in which so-called \"SP\" basis functions are found, defined by using a common exponent but different contraction coefficient for each of the 3 gaussians defining the actual s-type and p-type basis function. MOLOPT basis sets (see below) are built on this principle. Multiple- \\(\\zeta\\) basis sets use \\(\\zeta\\) basis functions for each atomic orbitals in the atom. For example, double- \\(\\zeta\\) basis sets use two basis function for each atomic orbital (e.g., a total of 10 basis function for the carbon). They may be grouped to share the same exponent, or not. On top of that, two other kind of basis function might be added: polarization functions , which have a larger angular momentum than those of the ground state of the atom (e.g., d-type basis functions for the carbon), and diffuse functions , which have very small exponents (corresponding to very \"large\" Gaussian functions). Thus, the number of basis function for a given atom is very different from one basis set to the other. Note One way to ease the communication is to report, for each shell, the number of primitives (uncontracted set) in the form (uncontracted set) , and the number of basis functions (contracted set) in the form [contracted set] . For example, in a double-zeta basis set defined by 3 gaussian per basis function, the result for carbn would be (12s,6p) and [3s,2p] . The form [12s6p|3s2p] , combining the two is also found. However, for reasons that will become clear in the next section, CP2K does not only use all-electron basis sets.","title":"Basis sets"},{"location":"users/basis_sets_and_pseudos/#gth-pseudopotentials","text":"Indeed, CP2K is able use an auxiliary plane wave (PW) basis set to perform its calculation with the GPW (and GAPW) method. To perform a such calculation, one needs to include all possible PW below a given threshold. In fact, increasing this threshold will monotonously improve the quality of the result (and the length of the calculation!). However, area where the electron density is rapidly changing requires PW with small wavelengths/high energy to be well described (i.e., large Fourier components), so high threshold, which would make the calculation impossible in practice. In practice, area where such changes are important are mostly located near the nuclei, \"thanks\" its ionic potential \\(V(r) = - \\frac{Z}{r}\\) . Hopefully, core and valence shell are generally well (spatially and energetically) separated, and core electrons are relatively unperturbed by the surrounding (chemically inert). So the idea behind pseudopotentials is to replace the effect of the nuclei and the core electrons (which are considered frozen ) by an effective potential (below a given threshold \\(r_c\\) ), and the valence electrons basis functions by ones with fewer nodes (since they do not need to be orthogonal to the, now removed, valence orbital), but with the same behavior outside the core region (for \\(r > r_c\\) ). Derivation of a pseudopotential Say one has a set of (orthogonal) core states \\(\\{|\\chi_n\\rangle\\}\\) (with their corresponding eigenvalue \\(\\{E_n\\}\\) ). The goal is to construct a pseudo-state \\(|\\phi\\rangle\\) for a valence state \\(|\\psi\\rangle\\) (with its corresponding eigenvalue \\(E\\) ), in the form: \\[|\\psi\\rangle = |\\phi\\rangle + \\sum_n a_n |\\chi_n\\rangle.\\] Since the core and valence state must be orthogonal, \\(\\langle \\chi_m | \\psi \\rangle = 0 = \\langle \\chi_m | \\phi \\rangle + a_m\\) , so that \\[|\\psi\\rangle = |\\phi\\rangle - \\sum_n |\\chi_n\\rangle \\langle \\chi_n | \\phi\\rangle.\\] Substituting in Schr\u00f6dinger equation for \\(|\\psi\\rangle\\) gives \\[\\hat H |\\phi\\rangle + \\sum_n (E-E_n) |\\chi_n\\rangle \\langle \\chi_n | \\phi\\rangle = E|\\phi\\rangle.\\] The pseudo-state thus obeys \\([\\hat H + \\hat V_{n\\ell}]\\, |\\phi\\rangle = E\\,|\\phi\\rangle\\) with: \\[\\hat V_{n\\ell} = \\sum_{n\\ell} (E-E_{n\\ell})\\,|\\chi_{n\\ell}\\rangle \\langle \\chi_{n\\ell} |.\\] where the energy of \\(|\\phi\\rangle\\) is the same as the one of \\(|\\psi\\rangle\\) , thanks to the pseudopotential \\(\\hat V_{n\\ell}\\) . This extra potential depends on the quantum numbers \\(n\\) and \\(\\ell\\) due to its spherical symmetry. Furthermore, since \\(E > E_{n\\ell}\\) , it is a repulsive potenial. In practice, pseudopotential expressions are separated into a fully nonlocal form, thanks to the Kleinman-Bylander Transformation (see 10.1103/PhysRevLett.48.1425 ). Latter on, Goedecker, Teter and Hutter (GTH, see 10.1103/PhysRevB.54.1703 ) derived expressions those two parts which are suited for real and Fourier space integration and only requires a few adjustable parameters (in blue): \\[\\hat V_{PP} = \\hat V_{loc} + \\sum_{\\ell}^{\\textcolor{blue}{\\ell_{max}}} \\hat V_{nl,\\ell},\\] with \\[V_{loc}(r) = -\\frac{Z'}{r}\\,\\text{erf}\\left[\\frac{\\bar r}{\\sqrt 2}\\right] + \\exp\\left[-\\frac{\\bar r^2}{2}\\right] \\sum_{i=1}^4 \\textcolor{blue}{C_i}\\,\\bar r^{2i-2}, \\text{ with } \\bar r = \\frac{r}{\\textcolor{blue}{r_c}},\\] and \\[V_{nl,\\ell} = \\sum_{ij}^{\\textcolor{blue}{N}} \\textcolor{blue}{h_{\\ell,ij}} \\,|p_{\\ell,i}\\rangle \\langle p_{\\ell,j}|, \\text{ with } p_{\\ell,i}(r) = N_{\\ell,i}(r)\\,\\exp\\left[-\\frac{\\bar r^2}{2}\\right] \\text{ and } \\bar r = \\frac{r}{\\textcolor{blue}{r_{nl,\\ell}}}.\\] In the former, \\(Z'\\) is the ionic charge (i.e., the charge of the nucleus minus the one of the core electrons), while in the latter, \\(N_\\ell(r)\\) is a combination of spherical harmonic multiplied by a \\(\\ell\\) -dependent radial function. All the parameters in blue, together with the number of core electrons in each shell, define a GTH pseudopotential in CP2K (see, e.g., 10.1007/s00214-005-0655-y ). In particular, they are given as a local part plus a set of nonlinear projectors. Note It is totally possible, for a given atom, to have pseudopotentials with a different number of core electrons embeded in the potential: while a small number of core electrons ensure a good transferability (but lengthen the calculation), a large number results in a smoother potential.","title":"GTH pseudopotentials"},{"location":"users/basis_sets_and_pseudos/#pairing-gth-pseudopotentials-with-basis-sets","text":"Warning In practice, the number electron is dictated by the pseudopotential (which lists the number of valence electrons in each shell). CP2K will blindly use whatever basis set you give, since it has no way to check the information on the basis set side (not even the names, which are merely conventions). From the previous paragraph, it appears that one has to pair a given pseudopotential with a correctly defined basis set, that has been designed with the correct amount of core electron removed and that contains smoother (pseudo-) basis functions. Names of pseudopotentials and basis sets help to achieve this association: GTH pseudopotential are generally named GTH-<XFC> , where <XCF> is the name of a XC-functional. It is thus strongly suggested to use them together with the XCF in question. For a given atom, such potentials are nicknamed GTH-<XFC>-q<N> , where <N> is the number of valence electrons considered while building the potential. For example, a pseudopotential for carbon is nicknamed GTH-BLYP-q4 , indicate that this pseudopotential was designed with BLYP, and that was built using 4 valence electrons (so it embedded a total of 2 core electrons). Basis sets are generally named <XZ>-<NAME>-<XCF>-GTH or <XZ>-GTH-<XCF> (though this is definitely not an absolute rule!), where <XZ> describe the content of the basis set (e.g., DZV for double zeta, TZVP for triple zeta with extra polarization, etc), <NAME> is the name of the family (e.g., MOLOPT ) and <XCF> is the name of the XCF used to optimize the basis set. The <XCF> may not be present in the name: for example, TZVP-MOLOPT-GTH should work with all XCF, while TZVP-MOLOPT-PBE-GTH was specifically designed with PBE. The latter probably gives better results and should (probably) be preferred. Again, for each atom, a suffix -q<N> is added, indicated how much valence electrons were not considered while building this basis set. For example, for carbon, the nickname DZVP-MOLOPT-GTH-q4 indicates that this is a double-zeta basis set (plus polarization functions) of the MOLOPT family, designed to work with GTH pseudopotentials embedding 2 core electrons. Where are the basis sets and GTH pseudopotentials? When running a CP2K calculation, you have to provide two files, containing the basis set(s) and pseudopotential(s) used in your calculation: &DFT BASIS_SET_FILE_NAME BASIS_SET POTENTIAL_FILE_NAME GTH_POTENTIALS &END DFT Basis sets and pseudopotentials are scattered across different file in the CP2K data folder . However, the web interface of this project proposes an easier way to build your own taylor-made BASIS_SET and GTH_POTENTIALS files. This is equivalent, since the data are obtained from the same source and just presented with a shiny interface ;) If you are interested, the format of those two files is described here","title":"Pairing GTH pseudopotentials with basis sets"},{"location":"users/basis_sets_and_pseudos/#working-with-all-electron-basis-sets","text":"Info The GAPW method is introduced, e.g., here or in 10.1007/s002140050523 . There also exists a special pseudopotential, ALL , which should be used for all-electron calculations. This is the pseudopotential of choice for GAPW calculations. It can be used with your usual all-electron basis sets (such as STO-3G, e.g., found in the BSE ). A curated list is available in the EMSL_BASIS_SETS file . Specially designed basis sets were also derived (found, e.g., in the ALL_BASIS_SETS file ), which contains ALL in their name or ends by -ae . The -q<N> number, if it exists (it is generally omitted), should be equal to the atomic number.","title":"Working with all-electron basis sets"},{"location":"users/webserver/","text":"How to use the web interface? \u00a4 Info If you are not familiar with the concept of basis set and pseudopotentials, check out this introduction . As usual with quantum chemistry calculations, to run CP2K, you need a geometry and a method. For the latter, if you want to use the GPW method (and, to some extent, the GAPW method), you will need to pick a basis set and a matching pseudopotential, which is the goal of this web interface. Example \u00a4 Say you want to optimize the water molecule . In particular, your input looks like: &FORCE_EVAL METHOD QS &SUBSYS &CELL ABC 12.4138 12.4138 12.4138 &END CELL &COORD O 12.235322 1.376642 10.869880 H 12.415139 2.233125 11.257611 H 11.922476 1.573799 9.986994 &END COORD &KIND H BASIS_SET ?? ! <- pick one POTENTIAL ?? ! <- pick one &END KIND &KIND O BASIS_SET ?? ! <- pick one POTENTIAL ?? ! <- pick one &END KIND &END SUBSYS &DFT BASIS_SET_FILE_NAME BASIS_SET ! <- should contain your basis set(s) POTENTIAL_FILE_NAME GTH_POTENTIALS ! <- should contain your pseudo(s) &XC &XC_FUNCTIONAL ?? ! <- pick one &END XC_FUNCTIONAL &END XC # (...) &END DFT &END FORCE_EVAL # (...) If you already know the method \u00a4 If you already know which basis set and pseudopotential you want to use, say DZVP-MOLOPT-GTH with GTH-BLYP (and the BLYP XC-functional), select them in the corresponding lists: You can use the search bar in the top of each list to quickly access the basis set or pseudopotential you are looking for: It is also possible to sort the basis set per kind , with the dropdown on the right. The following kinds are available: Kind Description GTH GTH basis sets or pseudopotential. Opposite of ALL ALL All-electron basis set or (pseudo)potential. Opposite of GTH MOLOPT MOLOPT basis sets SR Short-range/confined basis sets, better for solids In the periodic table below, the red borders indicate that the basis set is available for these atoms, while the blue borders indicates that the pseudopotential is available : This combination is thus available for H and O (but also for C-F and Si-Cl). If you don't know the method \u00a4 If you don't know yet which basis set and potential you will use, you can already select the atoms in your calculation: If you do so, the list of basis sets and pseudopotentials update so that it only show the ones that are available for this selection. So you can pick whatever combination you want in these possibilities! And then? \u00a4 When you have selected a matching triplet of atoms, basis set and pseudopotential, the panels on the right should update with the result. In particular, the first panel should be copied in a BASIS_SET file that will be used by your calculation, while the second should be copied in a GTH_PSEUDOPOTENTIALS file: Info These panels also report when the library of basis sets and pseudo was built, as a comment. To ease your life latter (check for errors), it might be useful to keep it. It also gives the address to the API call that generates this output , if you want. If you use a recent brower, you can use the copy button to perform the copy . The information button, opens an extra area with some info on the basis set or pseudopotential, in particular the references you need to cite in your articles: Finally, a last panel gives you the &KIND sections that you can just copy-paste in your input: Don't forget to update the &XC_FUNCTIONAL section... Et voil\u00e0 ! Peculiarity \u00a4 The web interface tries to ensure that the same number of core electron is used for the basis set and pseudopotential, thanks to the -q<N> nickname that is given for each atom . This has two (interesting!) side effects: For some elements, you have multiple possibilities (called \"variant\" by the web interface), indicated by comments: In this case, you can safely replace -q3 (all-electron) by -q1 (2 core electron embedded in the pseudopotential) for both the basis set and the potential, since they are both available (see the two panels in the top). It will, of course, impact the results. If you select combination that are incompatible (e.g., the all-electron pseudopotential ALL with a pseudo basis set), it will be indicated: You should thus reflect on your choices since running such calculation would be a mistake \ud83d\ude09 API \u00a4 If you want to interface this service with others, there is also an API available. This API actually feeds the web interface, so it should be easy for you to provide a similar service if you want to.","title":"How to use the web interface?"},{"location":"users/webserver/#how-to-use-the-web-interface","text":"Info If you are not familiar with the concept of basis set and pseudopotentials, check out this introduction . As usual with quantum chemistry calculations, to run CP2K, you need a geometry and a method. For the latter, if you want to use the GPW method (and, to some extent, the GAPW method), you will need to pick a basis set and a matching pseudopotential, which is the goal of this web interface.","title":"How to use the web interface?"},{"location":"users/webserver/#example","text":"Say you want to optimize the water molecule . In particular, your input looks like: &FORCE_EVAL METHOD QS &SUBSYS &CELL ABC 12.4138 12.4138 12.4138 &END CELL &COORD O 12.235322 1.376642 10.869880 H 12.415139 2.233125 11.257611 H 11.922476 1.573799 9.986994 &END COORD &KIND H BASIS_SET ?? ! <- pick one POTENTIAL ?? ! <- pick one &END KIND &KIND O BASIS_SET ?? ! <- pick one POTENTIAL ?? ! <- pick one &END KIND &END SUBSYS &DFT BASIS_SET_FILE_NAME BASIS_SET ! <- should contain your basis set(s) POTENTIAL_FILE_NAME GTH_POTENTIALS ! <- should contain your pseudo(s) &XC &XC_FUNCTIONAL ?? ! <- pick one &END XC_FUNCTIONAL &END XC # (...) &END DFT &END FORCE_EVAL # (...)","title":"Example"},{"location":"users/webserver/#if-you-already-know-the-method","text":"If you already know which basis set and pseudopotential you want to use, say DZVP-MOLOPT-GTH with GTH-BLYP (and the BLYP XC-functional), select them in the corresponding lists: You can use the search bar in the top of each list to quickly access the basis set or pseudopotential you are looking for: It is also possible to sort the basis set per kind , with the dropdown on the right. The following kinds are available: Kind Description GTH GTH basis sets or pseudopotential. Opposite of ALL ALL All-electron basis set or (pseudo)potential. Opposite of GTH MOLOPT MOLOPT basis sets SR Short-range/confined basis sets, better for solids In the periodic table below, the red borders indicate that the basis set is available for these atoms, while the blue borders indicates that the pseudopotential is available : This combination is thus available for H and O (but also for C-F and Si-Cl).","title":"If you already know the method"},{"location":"users/webserver/#if-you-dont-know-the-method","text":"If you don't know yet which basis set and potential you will use, you can already select the atoms in your calculation: If you do so, the list of basis sets and pseudopotentials update so that it only show the ones that are available for this selection. So you can pick whatever combination you want in these possibilities!","title":"If you don't know the method"},{"location":"users/webserver/#and-then","text":"When you have selected a matching triplet of atoms, basis set and pseudopotential, the panels on the right should update with the result. In particular, the first panel should be copied in a BASIS_SET file that will be used by your calculation, while the second should be copied in a GTH_PSEUDOPOTENTIALS file: Info These panels also report when the library of basis sets and pseudo was built, as a comment. To ease your life latter (check for errors), it might be useful to keep it. It also gives the address to the API call that generates this output , if you want. If you use a recent brower, you can use the copy button to perform the copy . The information button, opens an extra area with some info on the basis set or pseudopotential, in particular the references you need to cite in your articles: Finally, a last panel gives you the &KIND sections that you can just copy-paste in your input: Don't forget to update the &XC_FUNCTIONAL section... Et voil\u00e0 !","title":"And then?"},{"location":"users/webserver/#peculiarity","text":"The web interface tries to ensure that the same number of core electron is used for the basis set and pseudopotential, thanks to the -q<N> nickname that is given for each atom . This has two (interesting!) side effects: For some elements, you have multiple possibilities (called \"variant\" by the web interface), indicated by comments: In this case, you can safely replace -q3 (all-electron) by -q1 (2 core electron embedded in the pseudopotential) for both the basis set and the potential, since they are both available (see the two panels in the top). It will, of course, impact the results. If you select combination that are incompatible (e.g., the all-electron pseudopotential ALL with a pseudo basis set), it will be indicated: You should thus reflect on your choices since running such calculation would be a mistake \ud83d\ude09","title":"Peculiarity"},{"location":"users/webserver/#api","text":"If you want to interface this service with others, there is also an API available. This API actually feeds the web interface, so it should be easy for you to provide a similar service if you want to.","title":"API"}]}